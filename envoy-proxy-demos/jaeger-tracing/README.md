# Distributed Tracing: Jaeger Tracing

## Demo Overview
This is a Jaeger tracing example built based on the [Envoy sandboxes (Jaeger Tracing)](https://www.envoyproxy.io/docs/envoy/latest/start/sandboxes/jaeger_tracing) that demonstrates Envoy’s [tracing](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/tracing#arch-overview-tracing) capabilities using [Jaeger](https://www.jaegertracing.io/) as the tracing provider.

All services in the demo support not only `service` endpoint (which is basically the same as [HTTP Routing: Simple Match Routing](../httproute-simple-match/README.md)) but also `trace` endpoint. All traffic is routed by the `front envoy` to the `service containers`. Internally the traffic is routed to the service envoys, then the service envoys route the request to the flask app via the loopback address. All trace data is collected into a `Jaeger` container.

![](../assets/demo-jaeger-tracing.png)

### Endpoint - trace
In accessing to `trace` endpoint, all traffic is routed to the service envoys with trace header propagations like this:

- A request (path `/trace/blue` & port `8000`) is routed to `service_blue` 
  - `service_blue` internally calls `service_green` that then internally calls `service_red` with `trace header propagations`
- A request (path `/trace/green` & port `8000`) is routed to `service_green`
  - `service_blue` internally calls `service_red` with `trace header propagations`
- A request (path `/trace/red` & port `8000`) is routed to `service_red`

![](../assets/demo-jaeger-tracing-req-trace.png)

#### Key configuration 1: The HTTP connection manager 
All envoys are configured to collect request traces (e.g., http_connection_manager/config/tracing setup in front envoy).
```
  - filters:
    - name: envoy.http_connection_manager
      config:
        tracing:
          operation_name: egress
```
> - The HTTP connection manager that handles the request must have the tracing object set. Please refer to [tracing object](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/network/http_connection_manager/v2/http_connection_manager.proto#envoy-api-msg-config-filter-network-http-connection-manager-v2-httpconnectionmanager-tracing).
> - `operation_name`: The span name will be derived from this field (`ingress` or `egress`)
>   - `ingress` (default): ⁣The HTTP listener is used for ingress/incoming requests.
>   - `egress`: The HTTP listener is used for egress/outgoing requests

#### Key configuration 2: Spans propagation setup (Trace deiver setup)

All envoys in the demo are also configured to setup to propagate the spans generated by the Jaeger tracer to a Jaeger cluster.

```YAML
static_resources:
...
  clusters:
  ...
  - name: jaeger
    connect_timeout: 1s
    type: strict_dns
    lb_policy: round_robin
    hosts:
    - socket_address:
        address: jaeger
        port_value: 9411
tracing:
  http:
    name: envoy.zipkin
    config:
      collector_cluster: jaeger
      collector_endpoint: "/api/v1/spans"
      shared_span_context: false
```
> Presence of the object defines whether the connection manager emits tracing data to the configured tracing provider. You configure `tracing driver` in `name` field. Here are 4 parameter options for `tracing driver` and `envoy.zipkin` is selected here:
> - envoy.lightstep
> - envoy.zipkin
> - envoy.dynamic.ot
> - envoy.tracers.datadog

> Parameters for Config parts in zipkin deiver are [here](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/trace/v2/trace.proto#envoy-api-msg-config-trace-v2-zipkinconfig)

#### Key configuration 3: Trace header propagation
One of the most important benefits of tracing from Envoy is that it will take care of propagating the traces to the Jaeger service cluster. However, in order to fully take advantage of tracing, the application has to propagate trace headers that Envoy generates. The sample `trace header propagations` setup in servcie application code ([apps/service.py](../apps/service.py)) is this:

```python
# ...omit...

TRACE_HEADERS_TO_PROPAGATE = [
    'X-Ot-Span-Context',
    'X-Request-Id',

    # Zipkin headers
    'X-B3-TraceId',
    'X-B3-SpanId',
    'X-B3-ParentSpanId',
    'X-B3-Sampled',
    'X-B3-Flags',

    # Jaeger header (for native client)
    "uber-trace-id"
]

def render_page():
    return ('<body bgcolor="{}"><span style="color:white;font-size:4em;">\n'
            'Hello from {} (hostname: {} resolvedhostname:{})\n</span></body>\n'.format(
                    os.environ['SERVICE_NAME'],
                    os.environ['SERVICE_NAME'],
                    socket.gethostname(),
                    socket.gethostbyname(socket.gethostname())))

# ...omit...

@app.route('/trace/<service_color>')
def trace(service_color):
    headers = {}
    ## For Propagation test ##
    # Call service 'green' from service 'blue'
    if (os.environ['SERVICE_NAME']) == 'blue':
        for header in TRACE_HEADERS_TO_PROPAGATE:
            if header in request.headers:
                headers[header] = request.headers[header]
        ret = requests.get("http://localhost:9000/trace/green", headers=headers)
    # Call service 'red' from service 'green'
    elif (os.environ['SERVICE_NAME']) == 'green':
        for header in TRACE_HEADERS_TO_PROPAGATE:
            if header in request.headers:
                headers[header] = request.headers[header]
        ret = requests.get("http://localhost:9000/trace/red", headers=headers)
    return render_page()

if __name__ == "__main__":
    app.run(host='127.0.0.1', port=8080, debug=True)
```

>  **Zipkin tracer**
- When using the `Zipkin tracer`, Envoy relies on the service to propagate the `B3 HTTP headers` ( `x-b3-traceid, x-b3-spanid, x-b3-parentspanid, x-b3-sampled, and x-b3-flags`). The x-b3-sampled header can also be supplied by an external client to either enable or disable tracing for a particular request. In addition, the single b3 header propagation format is supported, which is a more compressed format. Please refer to [B3 Header](https://www.envoyproxy.io/docs/envoy/latest/configuration/http_conn_man/headers#config-http-conn-man-headers-b3) for the detail. 


## Getting Started
```sh
$ git clone https://github.com/yokawasa/envoy-proxy-demos.git
$ cd envoy-proxy-demos/jaeger-tracing
```
> [NOTICE] Before you run this demo, make sure that all demo containers in previous demo are stopped!

## Run the Demo

### Build and Run containers

```sh
$ docker-compose up --build -d

# check all services are up
$ docker-compose ps --service

front-envoy
service_blue
service_green
service_red
jaeger

# List containers
$ docker-compose ps

             Name                           Command               State                                                   Ports
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
jaeger-tracing_front-envoy_1     /usr/bin/dumb-init -- /bin ...   Up      10000/tcp, 0.0.0.0:8000->80/tcp, 0.0.0.0:8001->8001/tcp
jaeger-tracing_jaeger_1          /go/bin/all-in-one-linux - ...   Up      14250/tcp, 14268/tcp, 0.0.0.0:16686->16686/tcp, 5775/udp, 5778/tcp, 6831/udp, 6832/udp,
                                                                          0.0.0.0:9411->9411/tcp
jaeger-tracing_service_blue_1    /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 80/tcp
jaeger-tracing_service_green_1   /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 80/tcp
jaeger-tracing_service_red_1     /bin/sh -c /usr/local/bin/ ...   Up      10000/tcp, 80/tcp
```

### Access each services and check tracing results

Access the following 3 endpoints for tracing test.
```
$ curl -s -v http://localhost:8000/trace/blue
$ curl -s -v http://localhost:8000/trace/green
$ curl -s -v http://localhost:8000/trace/red
```

For example, when you access `/trace/blue`, you'll see the following output
```sh
$ curl -s -v http://localhost:8000/trace/blue

*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8000 (#0)
> GET /trace/blue HTTP/1.1
> Host: localhost:8000
> User-Agent: curl/7.54.0
> Accept: */*
>
< HTTP/1.1 200 OK
< content-type: text/html; charset=utf-8
< content-length: 147
< server: envoy
< date: Sun, 17 Feb 2019 16:50:50 GMT
< x-envoy-upstream-service-time: 32
<
<body bgcolor="blue"><span style="color:white;font-size:4em;">
Hello from blue (hostname: 9f71b1513720 resolvedhostname:172.21.0.5)
</span></body>
* Connection #0 to host localhost left intact
```

Trace data would automatically have been generated and pushed to Jaeger via Envoy. In this part, check the Jaeger UI to see how the Jaeger visualize all the trace data collected. Here is a Jaeger UI url:

```
$ open http://localhost:16686
```

![](../assets/jaeger-ui.png)

You'll come up with Jager UI page like above, then search each traces. Here are example tracing results in Jaeger UI:

![](../assets/jaeger-ui-servide-blue.png)

![](../assets/jaeger-ui-servide-green.png)

![](../assets/jaeger-ui-servide-red.png)

## Stop & Cleanup

```sh
$ docker-compose down --remove-orphans --rmi all
```

---
[Top](../README.md)